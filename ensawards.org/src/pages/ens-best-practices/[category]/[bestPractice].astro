---
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";
import { BenchmarkResultBadge } from "../../../components/atoms/badges/BenchmarkResultBadge.tsx";
import BenchmarkResultCard from "../../../components/atoms/cards/BenchmarkResultCard.astro";
import SuggestionCard from "../../../components/atoms/cards/SuggestionCard.astro";
import ItemsList from "../../../components/molecules/ItemsList.astro";
import SubpageHero from "../../../components/molecules/SubpageHero.astro";
import DataLoadingError from "../../../components/organisms/DataLoadingError.astro";
import { APPS } from "../../../data/apps";
import { BEST_PRACTICE_CATEGORIES, nameYourSmartContracts } from "../../../data/bestPractices";
import Layout from "../../../layouts/Layout.astro";
import {
  calculateAppSupport,
  calculateAppsPassed,
  getBestPracticeBySlug,
} from "../../../utils/dataAccess";
import { markdownToHtml } from "../../../utils/markdown";
import { BenchmarkResultToBadgeStyles, getAppSupportColor } from "../../../utils/styles";
import { cn } from "../../../utils/tailwindClassConcatenation";
import { BenchmarkResult } from "../../../types/apps";
export function getStaticPaths() {
  const staticPaths = [];

  for (let category of BEST_PRACTICE_CATEGORIES) {
    category.bestPractices
      .filter((bestPractice) => bestPractice.id !== nameYourSmartContracts.id)
      .forEach((bestPractice) =>
        staticPaths.push({ params: { category: category.slug, bestPractice: bestPractice.slug } }),
      );
  }
  return staticPaths;
}

const { category, bestPractice } = Astro.params;
const images = import.meta.glob<{ default: ImageMetadata }>("/src/assets/*.{jpeg,jpg,png,gif,svg}");

const technicalSectionContentStyles = "w-fit text-base font-normal leading-7 text-gray-500";
const technicalSectionMinorHeaderStyles = "text-lg leading-normal font-semibold text-black";

const bestPracticeToDisplay = getBestPracticeBySlug(bestPractice);

// Get apps that have benchmarks for this specific best practice
const appsWithBenchmarks = APPS.map((app) => {
  const matchingBenchmark = app.benchmarks.find(
    (benchmark) =>
      benchmark.bestPracticeDetails.categorySlug === bestPracticeToDisplay?.categorySlug &&
      benchmark.bestPracticeDetails.id === bestPracticeToDisplay?.id,
  );

  return {
    app,
    benchmark: matchingBenchmark,
  };
});

// Filter out apps that don't have a benchmark for this best practice
const appsWithValidBenchmarks = appsWithBenchmarks.filter(
  ({ benchmark }) => benchmark !== undefined,
);

// Declare sort order for benchmark result (Pass → Partial Pass → Fail)
const resultOrder = {
  [BenchmarkResult.Pass]: 0,
  [BenchmarkResult.PartialPass]: 1,
  [BenchmarkResult.Fail]: 2,
};

// Sort benchmark results
const sortedAppsByBenchmark = appsWithValidBenchmarks.sort((a, b) => {
  // First sort by result
  const resultDiff = resultOrder[a.benchmark!.result] - resultOrder[b.benchmark!.result];
  if (resultDiff !== 0) return resultDiff;
  // Then sort alphabetically within those categories
  return a.app.name.localeCompare(b.app.name);
});

// Extract just the app objects for final result
const benchmarkedApps = sortedAppsByBenchmark.map(({ app }) => app);
---
  {
      bestPracticeToDisplay === undefined ? (
              // theoretically, because of Astro's build-time page generation, this should never happen
              <DataLoadingError />
          )
          :
          (
          <Layout pageMetadata={{
              title: `ENSAwards: ${bestPracticeToDisplay.name}`,
              description: bestPracticeToDisplay.description,
              url: `https://ensawards.org/ens-best-practices/${category}/${bestPractice}`
          }}>
                <SubpageHero
                    header={bestPracticeToDisplay.name}
                    description={bestPracticeToDisplay.description}
                    breadcrumbs={["ENS best practices", bestPracticeToDisplay.categoryName]}
                    additionalElements={[
                      {
                        name: "Category",
                        value: bestPracticeToDisplay.categoryName,
                        link: `/ens-best-practices/${category}`,
                      },
                      {
                        name: "Apps passed",
                        value: calculateAppsPassed(bestPracticeToDisplay),
                      },
                      {
                        name: "App support",
                        value: `${calculateAppSupport(bestPracticeToDisplay)}%`,
                      },
                    ]}>
                  <technical-info-anchor
                      data-id={bestPracticeToDisplay.id}
                      href={`#${bestPracticeToDisplay.id}-technical-info`}
                      id={`${bestPracticeToDisplay.id}-technical-info-anchor`}
                      slot="technicalSectionAnchor"
                      class="text-white transition-all duration-200 decoration-white/40 hover:decoration-white underline underline-offset-[25%] decoration-from-font hover:cursor-pointer"
                  >Learn More</technical-info-anchor
                  >
                </SubpageHero>
                <section
                    class="w-full box-border h-fit flex flex-col flex-nowrap justify-start items-center p-5 sm:pt-[60px] sm:px-8">
                  <ItemsList header="App benchmarks" containerStyles="sm:gap-2">
                      {
                          benchmarkedApps.map((app) => {
                              // the benchmark is certainly here because it was the reason an app was chosen for benchmarkedApps
          const relatedBenchmark = app.benchmarks.find(
                                  (benchmark) =>
                                      benchmark.bestPracticeDetails.name === bestPracticeToDisplay.name,
                              )!;

                              return (
                                      <BenchmarkResultCard
                                              name={app.name}
                                              notes={app.description}
                                              viewDetails={{
                                                  text: "App details",
                                                  link: `/app/${app.id}`,
                                              }}
                                              additionalInfo={[
                                                  {
                                                      category: "Type",
                                                      value: app.type,
                                                  },
                                              ]}>
                                                <BenchmarkResultBadge
                                                  slot="badge"
                                                  benchmark={relatedBenchmark}
                                                  className={
                                                      BenchmarkResultToBadgeStyles.get(relatedBenchmark.result)!
                                                  }
                                                  client:load
                                          />
                                          <Image
                                                  src={images[app.iconPath]()}
                                                  alt={`${app.name}-logo`}
                                                  slot="icon"
                                                  class="shrink-0 rounded-md w-10 h-10"
                                          />
                                      </BenchmarkResultCard>
                              );
                          })
                      }
                    <SuggestionCard whatsSuggested="benchmark result" />
                  </ItemsList>
                </section>
                <section
                    id={`${bestPracticeToDisplay.id}-technical-info`}
                    class="w-full box-border h-fit flex flex-col flex-nowrap justify-start items-center pt-10 sm:pt-6 pb-6 sm:pb-[60px] px-5 sm:px-8">
                  <div
                      class="w-full max-w-[1216px] flex flex-nowrap flex-row gap-20 justify-center items-start">
                    <div
                        class="max-w-[716px] flex flex-nowrap flex-col justify-center items-start gap-3">
                      <h2 class="text-2xl leading-none font-semibold text-black">
                        {bestPracticeToDisplay.technicalDetails.main.header}
                      </h2>
                      <p class={technicalSectionContentStyles} set:html={markdownToHtml(bestPracticeToDisplay.technicalDetails.main.content)} />
                      {
                        bestPracticeToDisplay.technicalDetails.sides.map(
                            (additionalContent) => (
                                <>
                                  <h3 class={technicalSectionMinorHeaderStyles}>
                                    {additionalContent.header}
                                  </h3>
                                  <p class={technicalSectionContentStyles} set:html={markdownToHtml(additionalContent.content)} />
                                </>
                            ),
                        )
                      }
                    </div>
                    <div
                        class="w-1/2 min-w-[300px] max-w-[420px] box-border h-fit hidden sm:flex flex-col flex-nowrap justify-center items-start gap-4 bg-gray-50 rounded-xl py-5 px-6">
                      <h4 class={technicalSectionMinorHeaderStyles}>
                        {bestPracticeToDisplay.name}
                      </h4>
                      <p class={technicalSectionContentStyles}>
                        {bestPracticeToDisplay.description}
                      </p>
                      <div class="bg-gray-200 h-[1px] self-stretch"></div>
                      <div
                          class="w-full flex flex-row flex-wrap justify-between items-center gap-6">
                          <div class="w-fit flex flex-col flex-nowrap justify-center items-start gap-0">
                              <p class="text-sm leading-normal font-normal text-muted-foreground">Category</p>
                              <a href={`/ens-best-practices/${category}`} class="text-sm leading-normal font-semibold text-black underline underline-offset-[25%] decoration-black/40 hover:decoration-black transition-all duration-200">
                                  {bestPracticeToDisplay.categoryName}
                              </a>
                          </div>
                          <div class="w-fit flex flex-col flex-nowrap justify-center items-start gap-0">
                              <p class="text-sm leading-normal font-normal text-muted-foreground">Apps passed</p>
                              <p class="text-sm leading-normal font-semibold text-black">
                                  {calculateAppsPassed(bestPracticeToDisplay)}
                              </p>
                          </div>
                          <div class="w-fit flex flex-col flex-nowrap justify-center items-start gap-0">
                              <p class="text-sm leading-normal font-normal text-muted-foreground">App support</p>
                              <p class={cn("text-sm leading-normal font-semibold", `text-${getAppSupportColor(calculateAppSupport(bestPracticeToDisplay))}`)}>
                                  {calculateAppSupport(bestPracticeToDisplay)}%
                              </p>
                          </div>
                      </div>
                    </div>
                  </div>
                </section>
                <script>
                  import { scrollWithOffset } from "../../../utils/domActions";

                  class AnchorToTechnicalInfo extends HTMLElement {
                    connectedCallback() {
                      const scrollAnchor = document.getElementById(
                          `${this.dataset.id}-technical-info-anchor`,
                      );
                      scrollAnchor.addEventListener("click", (event) => {
                        event.preventDefault();
                        scrollWithOffset(`${this.dataset.id}-technical-info`, 60);
                      });
                    }
                  }

                  customElements.define("technical-info-anchor", AnchorToTechnicalInfo);
                </script>
          </Layout>
          )
  }
